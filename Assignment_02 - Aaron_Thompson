/* ----------------------------------------------------------------------------
* Copyright &copy; 2016 Aaron Thompson <aamithompson@gmail.com>
* Released under the [MIT License] (http://opensource.org/licenses/MIT)
* ------------------------------------------------------------------------- */

#include <iostream>
#include <string>
#include<chrono>
#include<thread>

#ifndef CONSTANTS_H
#define CONSTANTS_H
// ----------------------------------------------------------------------------

/**
* Notes:
* - If you like, you can start reading about what this "unnamed `namespace`"
*   is for [here](http://www.comeaucomputing.com/techtalk/#nostatic).
*/
namespace {

	const unsigned int TERM_SIZE_X = 80;
	/**
	* The width of the terminal window, in characters.
	*/

	const unsigned int TERM_SIZE_Y = 25;
	/**
	* The height of the terminal window, in characters.
	*/


	const double RATIO_FILLED = 0.40;
	/**
	* How much of the neighborhood should be filled with shapes?
	*/


	const double RATIO_ALIKE_HAPPY = 1 / 2.0;
	/**
	* "I'll move if my neighbors aren't at least this much like me"
	*/

	const double RATIO_DIFFERENT_HAPPY = 1 / 5.0;
	/**
	* "I'll move if my neighbors aren't at least this much different than me"
	*/

}

// ----------------------------------------------------------------------------
#endif

class Buffer {
private:
	char * data_;
public:
	const unsigned int size_x;
	const unsigned int size_y;

	Buffer(unsigned int a, unsigned int b) : size_x(a), size_y(b) {
		data_ = new char[a * b];

		clear();
	}

	~Buffer() {
		delete[] data_;
	}

	char get(unsigned int x, unsigned int y) const {
		if (x < size_x && y < size_y)
			return data_[x, y];
		else {
			std::cerr << "ERROR: `Buffer::get`: index out of bounds\n";
			exit(1);
			return ' ';
		}
	}

	void set(unsigned int x, unsigned int y, char c) {
		if (x < size_x && y < size_y)
			data_[y*size_x + x] = c;
		else {
			std::cerr << "ERROR: `Buffer::set`: index out of bounds\n";
			exit(1);
		}
	}

	void set(unsigned int x, unsigned int y, std::string s) {
		const unsigned int i = x;

		for (int j = 0; j < s.length(); j++) {
			if (s[j] == '\n') {
				y++;
				x = i;
			}
			else {
				set(x, y, s[j]);
				x++;
			}
		}
	}

	void draw() const {
		for (int i = 0; i < size_x*size_y; i++) {
			std::cout << data_[i];

			if ((i + 1) % size_x == 0)
				std::cout << std::endl;
		}
	}

	void clear() {
		for (int i = 0; i < size_x*size_y; i++)
			data_[i] = ' ';
	}
};

class Neighborhood;

class Shape {
private:
	std::string type_;
	std::string type_art;

public:
	static const unsigned int size_x = 5;
	static const unsigned int size_y = 3;

	Shape(const std::string & type = "empty"){
		setType(type);
	}

	std::string getType() {
		return type_;
	}

	void setType(const std::string & type) {
		type_ = type;

		if (type_ == "empty") {
			type_art = "     \n"
					   "     \n"
					   "     \n";
		}
		else if (type_ == "triangle") {
			type_art = "  ,  \n"
					   " / \\ \n"
					   "/___\\\n";
		}
		else if (type_ == "square") {
			type_art = ".---.\n"
					   "|   |\n"
					   "'---'\n";
		}
		else {
			std::cerr << "ERROR: `Shape::setType`: invalid type\n";
			exit(1);
		}
	}

	void drawToBuffer(Buffer & b, unsigned int x, unsigned int y) const {
		b.set(x, y, type_art);
	}

	bool isHappy(const Neighborhood & n, unsigned x, unsigned y) const {
		return true;
	}
};

class Neighborhood {
	private:
		Shape * neighborhood_;
	public:
		const unsigned int size_x;
		const unsigned int size_y;

		Neighborhood(unsigned int a, unsigned int b) : size_x(a), size_y(b) {
			neighborhood_ = new Shape[a*b]();
		}

		~Neighborhood() {
			delete[] neighborhood_;
		}

		Shape get(unsigned int x, unsigned int y) const{
			if (x < size_x && y < size_y)
				return neighborhood_[y*size_x + x];
			else {
				std::cerr << "ERROR: `Neighborhood::get`: index out of bounds\n";
				exit(1);
			}
		}

		void set(unsigned int x, unsigned int y, const Shape & s) {
			if (x < size_x && y < size_y)
				neighborhood_[y*size_x + x] = s;
			else {
				std::cerr << "ERROR: `Neighborhood::set`: index out of bounds\n";
				exit(1);
			}
		}

		void fill(float ratio) {
			int triangles = (size_x*size_y*ratio) / 2;
			int squares = (size_x*size_y*ratio) / 2;
			int empty = (size_x*size_y - triangles - squares);
			//random shape fill
		}

		void move(unsigned int old_x, unsigned int old_y) {
			for (int i = 0; i < size_x*size_y; i++) {
				//random sort algorithm needed
				int random_x = 0;
				int random_y = 0;

				//if(neighborhood_[random_y*size_x + random_x])
			}
		}

		void animate(unsigned int frames) {
			Buffer b(Shape::size_x*size_x, Shape::size_y*size_y);

			int unhappyShapeCount = 0;

			for (int i = 0; i < size_y; i++) {
				for (int j = 0; j < size_x; j++) {
					if (!neighborhood_[i*size_x + j].isHappy(*this, i, j))
						unhappyShapeCount++;
				}
			}

			while (unhappyShapeCount > 0) {
				for (int i = 0; i < size_y; i++) {
					for (int j = 0; j < size_x; j++) {
						neighborhood_[i*size_x + j].drawToBuffer(b, j*Shape::size_x, i*Shape::size_y);
					}
				}

				for (int i = 0; i < size_y; i++) {
					for (int j = 0; j < size_x; j++) {
						if (!neighborhood_[i*size_x + j].isHappy(*this, i, j)) {
							move(j, i);
							if (!neighborhood_[i*size_x + j].isHappy(*this, i, j))
								unhappyShapeCount--;
						}
					}
				}

				b.draw();
				std::this_thread::sleep_for(std::chrono::milliseconds(1000 / frames));
			}
		}
};

void test_buffer() {
	Buffer b(TERM_SIZE_X, TERM_SIZE_Y);

	// draw ellipse
	for (int y = 0; y < b.size_y; y++)
		for (int x = 0; x < b.size_x; x++)
			if ((x - 40)*(x - 40) + (y - 10)*(y - 10) == 50)
				b.set(x, y, '*');

	// draw boarder
	for (int y = 0; y < b.size_y; y++) {
		b.set(0, y, '|');
		b.set(b.size_x - 1, y, '|');
	}
	for (int x = 0; x < b.size_x; x++) {
		b.set(x, 0, '-');
		b.set(x, b.size_y - 1, '-');
	}

	// render to screen
	b.draw();
}

void test_shape() {
	Buffer b(TERM_SIZE_X, TERM_SIZE_Y);

	Shape triangle("triangle");
	Shape square("square");

	// draw shapes
	for (int y = 0; y <= b.size_y - Shape::size_y; y += Shape::size_y) {
		for (int x = 0; x <= b.size_x - Shape::size_x * 2; x += Shape::size_x * 2) {
			triangle.drawToBuffer(b, x + Shape::size_x*((y + 0) % 2), y);
			square.drawToBuffer(b, x + Shape::size_x*((y + 1) % 2), y);
		}
	}

	// render to screen
	b.draw();
}

int main() {
	char c;

	test_buffer();
	std::cin >> c;

	test_shape();
	std::cin >> c;

	unsigned int size_x = TERM_SIZE_X / Shape::size_x;
	unsigned int size_y = TERM_SIZE_Y / Shape::size_y;
	Neighborhood n(size_x, size_y);
	n.animate(4);

	return 0;
}
